<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <title>anttask - Yeti API documentation </title>
    <style type="text/css">

    body{
         font-family: "Lucida Grande","Trebuchet MS","Bitstream Vera Sans",Verdana,Helvetica,sans-serif;font-size: 14px;
         line-height: 18px;
    }

    h4 {
        margin: 0;
    }

    p {
        margin-top: 3px;
    }

    ul {
        list-style: none;
        margin: 0;
        padding:0;
    }

    body{
        margin:0;
        padding:0;
        line-height: 1.5em;
    }

    b{font-size: 110%;}
    em{color: red;}
    .var-marker {font-size: 80%; color: #666;}
    .struct-marker {font-size: 60%; color: #666;}

    pre.doc {
         font-family: "Lucida Grande","Trebuchet MS","Bitstream Vera Sans",Verdana,Helvetica,sans-serif;font-size: 14px;
         line-height: 18px;
    }

    pre.type {
        white-space: pre-wrap;
        white-space: -moz-pre-wrap;
        white-space: -o-pre-wrap;
        background: #faf8f0;
    }

    code {
        display: block;
        padding: 0.5em 1em;
        border: 1px solid #bebab0;
    }
    div.codeheader {
        margin-bottom: 0;
        padding-bottom: 0;
    }
    pre.codeheader {
        margin-top: 3px;
    }

    #topsection{
        background: #EAEAEA;
        height: 90px; /*Height of top section*/
    }

    #topsection h1{
        margin: 0;
        padding-top: 15px;
    }

    #contentwrapper{
        float: left;
        width: 100%;
    }

    #contentcolumn{
        margin-left: 200px; /*Set left margin to LeftColumnWidth*/
        border-left: 5px solid  #EAEAEA;
    }

    #leftcolumn{
        float: left;
        width: 200px; /*Width of left column*/
        margin-left: -100%;
        margin-top: 15px;
        
        /*background: #C8FC98;*/
    }

    #footer{
        clear: left;
        width: 100%;
        background: black;
        color: #FFF;
        text-align: center;
        padding: 4px 0;
    }

    #footer a{
        color: #FFFF80;
    }

    .innertube{
        margin: 10px; /*Margins for inner DIV inside each column (to provide padding)*/
        margin-top: 0;
    }

    </style>


</head>
<body>
<div id="maincontainer">
    <div id="topsection"><div class="innertube">
        <h1>Yeti API documentation </h1>
        <h2>anttask</h2>
    </div></div>

    <div id="contentwrapper"><div id="contentcolumn"><div class="innertube">
                <h1>yeti.lang.std<span class="struct-marker"> is structure</span> </h1>
        <a href="#source">sourcecode</a>
        <h2>Overview</h2>
        <pre class="doc"> Yeti standard library</pre>
       <h4>All Fields</h4>
        <p><a href="#field_!=">!=</a>, <a href="#field_!~">!~</a>, <a href="#field_%">%</a>, <a href="#field_&#60;">&#60;</a>, <a href="#field_&#60;=">&#60;=</a>, <a href="#field_&#62;">&#62;</a>, <a href="#field_&#62;=">&#62;=</a>, <a href="#field_*">*</a>, <a href="#field_+">+</a>, <a href="#field_++">++</a>, <a href="#field_-">-</a>, <a href="#field_.">.</a>, <a href="#field_/">/</a>, <a href="#field_:.">:.</a>, <a href="#field_::">::</a>, <a href="#field_==">==</a>, <a href="#field_=~">=~</a>, <a href="#field_^">^</a>, <a href="#field_abs">abs</a>, <a href="#field_acos">acos</a>, <a href="#field_all">all</a>, <a href="#field_and">and</a>, <a href="#field_any">any</a>, <a href="#field_apply">apply</a>, <a href="#field_array">array</a>, <a href="#field_asin">asin</a>, <a href="#field_at">at</a>, <a href="#field_atan">atan</a>, <a href="#field_avoid">avoid</a>, <a href="#field_b_and">b_and</a>, <a href="#field_b_or">b_or</a>, <a href="#field_catSome">catSome</a>, <a href="#field_clearHash">clearHash</a>, <a href="#field_collect">collect</a>, <a href="#field_concat">concat</a>, <a href="#field_concatMap">concatMap</a>, <a href="#field_const">const</a>, <a href="#field_contains">contains</a>, <a href="#field_copy">copy</a>, <a href="#field_cos">cos</a>, <a href="#field_defined?">defined?</a>, <a href="#field_delete">delete</a>, <a href="#field_deleteAll">deleteAll</a>, <a href="#field_div">div</a>, <a href="#field_drop">drop</a>, <a href="#field_empty?">empty?</a>, <a href="#field_exp">exp</a>, <a href="#field_failWith">failWith</a>, <a href="#field_filter">filter</a>, <a href="#field_find">find</a>, <a href="#field_flip">flip</a>, <a href="#field_fold">fold</a>, <a href="#field_for">for</a>, <a href="#field_forHash">forHash</a>, <a href="#field_groupBy">groupBy</a>, <a href="#field_hash">hash</a>, <a href="#field_head">head</a>, <a href="#field_id">id</a>, <a href="#field_identityHash">identityHash</a>, <a href="#field_in">in</a>, <a href="#field_index">index</a>, <a href="#field_insertHash">insertHash</a>, <a href="#field_int">int</a>, <a href="#field_iterate">iterate</a>, <a href="#field_keys">keys</a>, <a href="#field_lazy">lazy</a>, <a href="#field_length">length</a>, <a href="#field_like">like</a>, <a href="#field_list">list</a>, <a href="#field_ln">ln</a>, <a href="#field_map">map</a>, <a href="#field_map'">map'</a>, <a href="#field_map2">map2</a>, <a href="#field_mapHash">mapHash</a>, <a href="#field_matchAll">matchAll</a>, <a href="#field_max">max</a>, <a href="#field_maybe">maybe</a>, <a href="#field_min">min</a>, <a href="#field_negate">negate</a>, <a href="#field_none">none</a>, <a href="#field_not">not</a>, <a href="#field_nub">nub</a>, <a href="#field_nullptr?">nullptr?</a>, <a href="#field_number">number</a>, <a href="#field_on">on</a>, <a href="#field_or">or</a>, <a href="#field_pair">pair</a>, <a href="#field_peekObject">peekObject</a>, <a href="#field_pi">pi</a>, <a href="#field_pop">pop</a>, <a href="#field_push">push</a>, <a href="#field_revAppend">revAppend</a>, <a href="#field_reverse">reverse</a>, <a href="#field_same?">same?</a>, <a href="#field_setArrayCapacity">setArrayCapacity</a>, <a href="#field_setHashDefault">setHashDefault</a>, <a href="#field_shift">shift</a>, <a href="#field_shl">shl</a>, <a href="#field_shr">shr</a>, <a href="#field_sin">sin</a>, <a href="#field_slice">slice</a>, <a href="#field_sort">sort</a>, <a href="#field_sortBy">sortBy</a>, <a href="#field_splitAt">splitAt</a>, <a href="#field_splitBy">splitBy</a>, <a href="#field_sqrt">sqrt</a>, <a href="#field_strCapitalize">strCapitalize</a>, <a href="#field_strChar">strChar</a>, <a href="#field_strEnds?">strEnds?</a>, <a href="#field_strIndexOf">strIndexOf</a>, <a href="#field_strJoin">strJoin</a>, <a href="#field_strLastIndexOf">strLastIndexOf</a>, <a href="#field_strLastIndexOf'">strLastIndexOf'</a>, <a href="#field_strLeft">strLeft</a>, <a href="#field_strLeftOf">strLeftOf</a>, <a href="#field_strLength">strLength</a>, <a href="#field_strLower">strLower</a>, <a href="#field_strPad">strPad</a>, <a href="#field_strReplace">strReplace</a>, <a href="#field_strRight">strRight</a>, <a href="#field_strRightOf">strRightOf</a>, <a href="#field_strSlice">strSlice</a>, <a href="#field_strSplit">strSplit</a>, <a href="#field_strStarts?">strStarts?</a>, <a href="#field_strTrim">strTrim</a>, <a href="#field_strUncapitalize">strUncapitalize</a>, <a href="#field_strUpper">strUpper</a>, <a href="#field_string">string</a>, <a href="#field_substAll">substAll</a>, <a href="#field_sum">sum</a>, <a href="#field_swapAt">swapAt</a>, <a href="#field_synchronized">synchronized</a>, <a href="#field_tail">tail</a>, <a href="#field_take">take</a>, <a href="#field_takeWhile">takeWhile</a>, <a href="#field_tan">tan</a>, <a href="#field_threadLocal">threadLocal</a>, <a href="#field_withExit">withExit</a>, <a href="#field_wrapArray">wrapArray</a>, <a href="#field_xor">xor</a></p>

        <h2>Field details</h2><hr/>        <h3><a name="field_!=">!=</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>!= is 'a -&#62; 'a -&#62; boolean</code></pre>
        <hr/>
        <h3><a name="field_!~">!~</a></h3>
        <pre class="doc">negated regex match: s !~ p is same as not (s =~ p)</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>!~ is string -&#62; string -&#62; boolean</code></pre>
        <hr/>
        <h3><a name="field_%">%</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>% is number -&#62; number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_*">*</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>* is number -&#62; number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_+">+</a></h3>
        <pre class="doc">arithmetic operators</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>+ is number -&#62; number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_++">++</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>++ is list?&#60;'a&#62; -&#62; list?&#60;'a&#62; -&#62; list&#60;'a&#62;</code></pre>
        <hr/>
        <h3><a name="field_-">-</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>- is number -&#62; number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_.">.</a></h3>
        <pre class="doc">function composition - (f . g) x is same as f (g x)</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>. is ('a -&#62; 'b) -&#62; ('c -&#62; 'a) -&#62; 'c -&#62; 'b</code></pre>
        <hr/>
        <h3><a name="field_/">/</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>/ is number -&#62; number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_:.">:.</a></h3>
        <pre class="doc">lazy list constructor a :. \[b] is same as [a, b], but the second
 lambda is invoked only when the tail is accessed for the first time.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>:. is 'a -&#62; (() -&#62; list?&#60;'a&#62;) -&#62; list&#60;'a&#62;</code></pre>
        <hr/>
        <h3><a name="field_::">::</a></h3>
        <pre class="doc">list constructor a :: [b, c] is same as [a, b, c]</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>:: is 'a -&#62; list?&#60;'a&#62; -&#62; list&#60;'a&#62;</code></pre>
        <hr/>
        <h3><a name="field_&#60;">&#60;</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>&#60; is ^a -&#62; ^a -&#62; boolean</code></pre>
        <hr/>
        <h3><a name="field_&#60;=">&#60;=</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>&#60;= is ^a -&#62; ^a -&#62; boolean</code></pre>
        <hr/>
        <h3><a name="field_==">==</a></h3>
        <pre class="doc">comparision operators</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>== is 'a -&#62; 'a -&#62; boolean</code></pre>
        <hr/>
        <h3><a name="field_=~">=~</a></h3>
        <pre class="doc">regex match, like s =~ '\d' to check whether string s contains number</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>=~ is string -&#62; string -&#62; boolean</code></pre>
        <hr/>
        <h3><a name="field_&#62;">&#62;</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>&#62; is ^a -&#62; ^a -&#62; boolean</code></pre>
        <hr/>
        <h3><a name="field_&#62;=">&#62;=</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>&#62;= is ^a -&#62; ^a -&#62; boolean</code></pre>
        <hr/>
        <h3><a name="field_^">^</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>^ is 'a -&#62; 'b -&#62; string</code></pre>
        <hr/>
        <h3><a name="field_abs">abs</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>abs is number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_acos">acos</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>acos is number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_all">all</a></h3>
        <pre class="doc">Is predicate f true for all elements of list l?</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>all is ('a -&#62; boolean) -&#62; list?&#60;'a&#62; -&#62; boolean</code></pre>
        <hr/>
        <h3><a name="field_and">and</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>and is boolean -&#62; boolean -&#62; boolean</code></pre>
        <hr/>
        <h3><a name="field_any">any</a></h3>
        <pre class="doc">Is predicate f true for any element of list l?</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>any is ('a -&#62; boolean) -&#62; list?&#60;'a&#62; -&#62; boolean</code></pre>
        <hr/>
        <h3><a name="field_apply">apply</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>apply is 'a -&#62; ('a -&#62; 'b) -&#62; 'b</code></pre>
        <hr/>
        <h3><a name="field_array">array</a></h3>
        <pre class="doc">struct inner bindings are non-polymorphic</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>array is list?&#60;'a&#62; -&#62; array&#60;'a&#62;</code></pre>
        <hr/>
        <h3><a name="field_asin">asin</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>asin is number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_at">at</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>at is map&#60;'a, 'b&#62; -&#62; 'a -&#62; 'b</code></pre>
        <hr/>
        <h3><a name="field_atan">atan</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>atan is number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_avoid">avoid</a></h3>
        <pre class="doc">Returns first element of l for which predicate f is false
 or last element, when f returns false for all elements of l.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>avoid is ('a -&#62; boolean) -&#62; list?&#60;'a&#62; -&#62; 'a</code></pre>
        <hr/>
        <h3><a name="field_b_and">b_and</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>b_and is number -&#62; number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_b_or">b_or</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>b_or is number -&#62; number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_catSome">catSome</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>catSome is list?&#60;None 'a | Some 'b&#62; -&#62; list&#60;'b&#62;</code></pre>
        <hr/>
        <h3><a name="field_clearHash">clearHash</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>clearHash is hash&#60;'a, 'b&#62; -&#62; ()</code></pre>
        <hr/>
        <h3><a name="field_collect">collect</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>collect is ('a -&#62; 'b) -&#62; 'a -&#62; ('b -&#62; boolean) -&#62; list&#60;'b&#62;</code></pre>
        <hr/>
        <h3><a name="field_concat">concat</a></h3>
        <pre class="doc">Flatten a list of lists.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>concat is list&#60;list?&#60;'a&#62;&#62; -&#62; list&#60;'a&#62;</code></pre>
        <hr/>
        <h3><a name="field_concatMap">concatMap</a></h3>
        <pre class="doc">Basically concat . map, but more effective.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>concatMap is ('a -&#62; list?&#60;'b&#62;) -&#62; list?&#60;'a&#62; -&#62; list&#60;'b&#62;</code></pre>
        <hr/>
        <h3><a name="field_const">const</a></h3>
        <pre class="doc">constant function (K combinator)</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>const is 'a -&#62; 'b -&#62; 'a</code></pre>
        <hr/>
        <h3><a name="field_contains">contains</a></h3>
        <pre class="doc">Whether l contains element equal (as defined by (==)) to v</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>contains is 'a -&#62; list?&#60;'a&#62; -&#62; boolean</code></pre>
        <hr/>
        <h3><a name="field_copy">copy</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>copy is (map&#60;'a, 'b&#62; is 'c) -&#62; 'c</code></pre>
        <hr/>
        <h3><a name="field_cos">cos</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>cos is number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_defined?">defined?</a></h3>
        <pre class="doc">checks whether value is defined</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>defined? is 'a -&#62; boolean</code></pre>
        <hr/>
        <h3><a name="field_delete">delete</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>delete is map&#60;'a, 'b&#62; -&#62; 'a -&#62; ()</code></pre>
        <hr/>
        <h3><a name="field_deleteAll">deleteAll</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>deleteAll is map&#60;'a, 'b&#62; -&#62; list?&#60;'a&#62; -&#62; ()</code></pre>
        <hr/>
        <h3><a name="field_div">div</a></h3>
        <pre class="doc">integer operations (when arguments are rational or floating numbers,
 then only the integer part of argument is used))</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>div is number -&#62; number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_drop">drop</a></h3>
        <pre class="doc">Drop first n elements from list l. Won't copy the returned tail.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>drop is number -&#62; list&#60;'a&#62; -&#62; list&#60;'a&#62;</code></pre>
        <hr/>
        <h3><a name="field_empty?">empty?</a></h3>
        <pre class="doc">Check whether a collection is empty one.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>empty? is map&#60;'a, 'b&#62; -&#62; boolean</code></pre>
        <hr/>
        <h3><a name="field_exp">exp</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>exp is number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_failWith">failWith</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>failWith is string -&#62; 'a</code></pre>
        <hr/>
        <h3><a name="field_filter">filter</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>filter is ('a -&#62; boolean) -&#62; list?&#60;'a&#62; -&#62; list&#60;'a&#62;</code></pre>
        <hr/>
        <h3><a name="field_find">find</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>find is ('a -&#62; boolean) -&#62; list?&#60;'a&#62; -&#62; list&#60;'a&#62;</code></pre>
        <hr/>
        <h3><a name="field_flip">flip</a></h3>
        <pre class="doc">Applies function to two arguments in reversed order.
 Useful for swapping binary functions arguments.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>flip is ('a -&#62; 'b -&#62; 'c) -&#62; 'b -&#62; 'a -&#62; 'c</code></pre>
        <hr/>
        <h3><a name="field_fold">fold</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>fold is ('a -&#62; 'b -&#62; 'a) -&#62; 'a -&#62; list?&#60;'b&#62; -&#62; 'a</code></pre>
        <hr/>
        <h3><a name="field_for">for</a></h3>
        <pre class="doc">For every element of l call f with given element as argument.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>for is list?&#60;'a&#62; -&#62; ('a -&#62; ()) -&#62; ()</code></pre>
        <hr/>
        <h3><a name="field_forHash">forHash</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>forHash is hash&#60;'a, 'b&#62; -&#62; ('a -&#62; 'b -&#62; ()) -&#62; ()</code></pre>
        <hr/>
        <h3><a name="field_groupBy">groupBy</a></h3>
        <pre class="doc">Returns a list of lists, where each sublist contains only equal elements
 and the concatenation of the result is equal to the original list l.
 Elements are considered equal when the given predicate function
 eq is true for them.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>groupBy is ('a -&#62; 'a -&#62; boolean) -&#62; list?&#60;'a&#62; -&#62; list&#60;list&#60;'a&#62;&#62;</code></pre>
        <hr/>
        <h3><a name="field_hash">hash</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>hash is list?&#60;'a&#62; -&#62; hash&#60;'a, ()&#62;</code></pre>
        <hr/>
        <h3><a name="field_head">head</a></h3>
        <pre class="doc">First element of list or array.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>head is list?&#60;'a&#62; -&#62; 'a</code></pre>
        <hr/>
        <h3><a name="field_id">id</a></h3>
        <pre class="doc">identity function (I combinator)</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>id is 'a -&#62; 'a</code></pre>
        <hr/>
        <h3><a name="field_identityHash">identityHash</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>identityHash is () -&#62; hash&#60;'a, 'b&#62;</code></pre>
        <hr/>
        <h3><a name="field_in">in</a></h3>
        <pre class="doc">element a in hash b</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>in is 'a -&#62; map&#60;'a, 'b&#62; -&#62; boolean</code></pre>
        <hr/>
        <h3><a name="field_index">index</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>index is 'a -&#62; list?&#60;'a&#62; -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_insertHash">insertHash</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>insertHash is hash&#60;'a, 'b&#62; -&#62; hash&#60;'a, 'b&#62; -&#62; ()</code></pre>
        <hr/>
        <h3><a name="field_int">int</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>int is number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_iterate">iterate</a></h3>
        <pre class="doc">Returns infinite list [x, f(x), f(f(x)), f(f(f(x))), ...]</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>iterate is ('a -&#62; 'a) -&#62; 'a -&#62; list&#60;'a&#62;</code></pre>
        <hr/>
        <h3><a name="field_keys">keys</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>keys is hash&#60;'a, 'b&#62; -&#62; list&#60;'a&#62;</code></pre>
        <hr/>
        <h3><a name="field_lazy">lazy</a></h3>
        <pre class="doc">Make function f to be memoizing.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>lazy is (() -&#62; 'a) -&#62; () -&#62; 'a</code></pre>
        <hr/>
        <h3><a name="field_length">length</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>length is map&#60;'a, 'b&#62; -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_like">like</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>like is string -&#62; string -&#62; () -&#62; array&#60;string&#62;</code></pre>
        <hr/>
        <h3><a name="field_list">list</a></h3>
        <pre class="doc">Gives values from collection a as a list.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>list is map&#60;'a, 'b&#62; -&#62; list&#60;'b&#62;</code></pre>
        <hr/>
        <h3><a name="field_ln">ln</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>ln is number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_map">map</a></h3>
        <pre class="doc">Returns [f(a), f(b), ...] for list l [a, b, ...]
 This map function returns lazy list when used on normal lists.
 Arrays and lists backed by arrays are mapped strictly.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>map is ('a -&#62; 'b) -&#62; list?&#60;'a&#62; -&#62; list&#60;'b&#62;</code></pre>
        <hr/>
        <h3><a name="field_map'">map'</a></h3>
        <pre class="doc">Strict mapping of list. map' is usually faster than map on lists,
 unless huge streams are processed or most of the resulting list is
 not used. They work identically on arrays.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>map' is ('a -&#62; 'b) -&#62; list?&#60;'a&#62; -&#62; list&#60;'b&#62;</code></pre>
        <hr/>
        <h3><a name="field_map2">map2</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>map2 is ('a -&#62; 'b -&#62; 'c) -&#62; list?&#60;'a&#62; -&#62; list?&#60;'b&#62; -&#62; list&#60;'c&#62;</code></pre>
        <hr/>
        <h3><a name="field_mapHash">mapHash</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>mapHash is ('a -&#62; 'b -&#62; 'c) -&#62; hash&#60;'a, 'b&#62; -&#62; list?&#60;'c&#62;</code></pre>
        <hr/>
        <h3><a name="field_matchAll">matchAll</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>matchAll is string -&#62; (array&#60;string&#62; -&#62; 'a) -&#62; (string -&#62; 'a) -&#62; string -&#62; list&#60;'a&#62;</code></pre>
        <hr/>
        <h3><a name="field_max">max</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>max is ^a -&#62; ^a -&#62; ^a</code></pre>
        <hr/>
        <h3><a name="field_maybe">maybe</a></h3>
        <pre class="doc">Returns default when opt == None () and f x when opt == Some x</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>maybe is 'a -&#62; ('b -&#62; 'a) -&#62; None 'c | Some 'b -&#62; 'a</code></pre>
        <hr/>
        <h3><a name="field_min">min</a></h3>
        <pre class="doc">Numeric functions</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>min is ^a -&#62; ^a -&#62; ^a</code></pre>
        <hr/>
        <h3><a name="field_negate">negate</a></h3>
        <pre class="doc">negate a = -a</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>negate is number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_none">none</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>none is None ()</code></pre>
        <hr/>
        <h3><a name="field_not">not</a></h3>
        <pre class="doc">functions for standard operators
 boolean logic</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>not is boolean -&#62; boolean</code></pre>
        <hr/>
        <h3><a name="field_nub">nub</a></h3>
        <pre class="doc">Removes duplicate elements from the list.
 The ordering of list is not preserved.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>nub is list?&#60;'a&#62; -&#62; list&#60;'a&#62;</code></pre>
        <hr/>
        <h3><a name="field_nullptr?">nullptr?</a></h3>
        <pre class="doc">Low-level nullpointer check.
 Use defined? instead, as nullptr? may behive unexpectedly together
 with some conversions done by yeti.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>nullptr? is 'a -&#62; boolean</code></pre>
        <hr/>
        <h3><a name="field_number">number</a></h3>
        <pre class="doc">Convert string into number</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>number is string -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_on">on</a></h3>
        <pre class="doc">f g x y = f (g x) (g y)
 for example sort (on (&#60;) (.name)) list</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>on is ('a -&#62; 'a -&#62; 'b) -&#62; ('c -&#62; 'a) -&#62; 'c -&#62; 'c -&#62; 'b</code></pre>
        <hr/>
        <h3><a name="field_or">or</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>or is boolean -&#62; boolean -&#62; boolean</code></pre>
        <hr/>
        <h3><a name="field_pair">pair</a></h3>
        <pre class="doc">Construct a pair structure.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>pair is 'a -&#62; 'b -&#62; {fst is 'a, snd is 'b}</code></pre>
        <hr/>
        <h3><a name="field_peekObject">peekObject</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>peekObject is 'a -&#62; (Boolean boolean
| Hash hash&#60;'b, 'b&#62;
| List list&#60;'b&#62;
| Number number
| Object ~java.lang.Object
| String string
| Struct {fields is list&#60;string&#62;, value is 'c -&#62; 'b}
| Variant {tag is string, value is 'b} is 'b)</code></pre>
        <hr/>
        <h3><a name="field_pi">pi</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>pi is number</code></pre>
        <hr/>
        <h3><a name="field_pop">pop</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>pop is array&#60;'a&#62; -&#62; 'a</code></pre>
        <hr/>
        <h3><a name="field_push">push</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>push is array&#60;'a&#62; -&#62; 'a -&#62; ()</code></pre>
        <hr/>
        <h3><a name="field_revAppend">revAppend</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>revAppend is list?&#60;'a&#62; -&#62; list&#60;'a&#62; -&#62; list&#60;'a&#62;</code></pre>
        <hr/>
        <h3><a name="field_reverse">reverse</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>reverse is list?&#60;'a&#62; -&#62; list&#60;'a&#62;</code></pre>
        <hr/>
        <h3><a name="field_same?">same?</a></h3>
        <pre class="doc">Identity check - whether a and b are reference to same object.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>same? is 'a -&#62; 'a -&#62; boolean</code></pre>
        <hr/>
        <h3><a name="field_setArrayCapacity">setArrayCapacity</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>setArrayCapacity is array&#60;'a&#62; -&#62; number -&#62; ()</code></pre>
        <hr/>
        <h3><a name="field_setHashDefault">setHashDefault</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>setHashDefault is hash&#60;'a, 'b&#62; -&#62; ('a -&#62; 'b) -&#62; ()</code></pre>
        <hr/>
        <h3><a name="field_shift">shift</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>shift is array&#60;'a&#62; -&#62; 'a</code></pre>
        <hr/>
        <h3><a name="field_shl">shl</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>shl is number -&#62; number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_shr">shr</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>shr is number -&#62; number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_sin">sin</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>sin is number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_slice">slice</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>slice is array&#60;'a&#62; -&#62; number -&#62; number -&#62; array&#60;'a&#62;</code></pre>
        <hr/>
        <h3><a name="field_sort">sort</a></h3>
        <pre class="doc">Sorts list. Same as sortBy (&#60;) l</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>sort is list?&#60;^a&#62; -&#62; list&#60;^a&#62;</code></pre>
        <hr/>
        <h3><a name="field_sortBy">sortBy</a></h3>
        <pre class="doc">Sorts list using given less? predicate function to determine the order.
 Merge sort algorithm is used.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>sortBy is ('a -&#62; 'a -&#62; boolean) -&#62; list?&#60;'a&#62; -&#62; list&#60;'a&#62;</code></pre>
        <hr/>
        <h3><a name="field_splitAt">splitAt</a></h3>
        <pre class="doc">Splits given list into two parts, returning first n elements as fst
 and the rest as snd.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>splitAt is number -&#62; (list&#60;'a&#62; is 'b) -&#62; {fst is list&#60;'a&#62;, snd is 'b}</code></pre>
        <hr/>
        <h3><a name="field_splitBy">splitBy</a></h3>
        <pre class="doc">Splits given list into two parts, putting elements from the start of the
 list into fst as long as predicate function pred is false for the given
 element. The rest of the list is returned as snd.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>splitBy is ('a -&#62; boolean) -&#62; (list&#60;'a&#62; is 'b) -&#62; {fst is list&#60;'a&#62;, snd is 'b}</code></pre>
        <hr/>
        <h3><a name="field_sqrt">sqrt</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>sqrt is number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_strCapitalize">strCapitalize</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>strCapitalize is string -&#62; string</code></pre>
        <hr/>
        <h3><a name="field_strChar">strChar</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>strChar is string -&#62; number -&#62; string</code></pre>
        <hr/>
        <h3><a name="field_strEnds?">strEnds?</a></h3>
        <pre class="doc">Does the string s ends with string end?</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>strEnds? is string -&#62; string -&#62; boolean</code></pre>
        <hr/>
        <h3><a name="field_strIndexOf">strIndexOf</a></h3>
        <pre class="doc">Get an index of the needle substring in the haystack.
 Starts searching from index from</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>strIndexOf is string -&#62; string -&#62; number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_strJoin">strJoin</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>strJoin is string -&#62; list?&#60;'a&#62; -&#62; string</code></pre>
        <hr/>
        <h3><a name="field_strLastIndexOf">strLastIndexOf</a></h3>
        <pre class="doc">Get an index of the needle substring in the haystack.
 Starts searching backwards from index from</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>strLastIndexOf is string -&#62; string -&#62; number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_strLastIndexOf'">strLastIndexOf'</a></h3>
        <pre class="doc">Same as strLastIndexOf haystack needle (strLength haystack)</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>strLastIndexOf' is string -&#62; string -&#62; number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_strLeft">strLeft</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>strLeft is string -&#62; number -&#62; string</code></pre>
        <hr/>
        <h3><a name="field_strLeftOf">strLeftOf</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>strLeftOf is string -&#62; string -&#62; string</code></pre>
        <hr/>
        <h3><a name="field_strLength">strLength</a></h3>
        <pre class="doc">String length</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>strLength is string -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_strLower">strLower</a></h3>
        <pre class="doc">String to lower case</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>strLower is string -&#62; string</code></pre>
        <hr/>
        <h3><a name="field_strPad">strPad</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>strPad is string -&#62; number -&#62; string -&#62; string</code></pre>
        <hr/>
        <h3><a name="field_strReplace">strReplace</a></h3>
        <pre class="doc">Replaces occurences of needle in the haystack with replacement</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>strReplace is string -&#62; string -&#62; string -&#62; string</code></pre>
        <hr/>
        <h3><a name="field_strRight">strRight</a></h3>
        <pre class="doc">Same as strSlice s pos (strLength s)</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>strRight is string -&#62; number -&#62; string</code></pre>
        <hr/>
        <h3><a name="field_strRightOf">strRightOf</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>strRightOf is string -&#62; string -&#62; string</code></pre>
        <hr/>
        <h3><a name="field_strSlice">strSlice</a></h3>
        <pre class="doc">Slice of the string</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>strSlice is string -&#62; number -&#62; number -&#62; string</code></pre>
        <hr/>
        <h3><a name="field_strSplit">strSplit</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>strSplit is string -&#62; string -&#62; array&#60;string&#62;</code></pre>
        <hr/>
        <h3><a name="field_strStarts?">strStarts?</a></h3>
        <pre class="doc">Does the string s starts with string start?</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>strStarts? is string -&#62; string -&#62; boolean</code></pre>
        <hr/>
        <h3><a name="field_strTrim">strTrim</a></h3>
        <pre class="doc">Remove whitespace from start and end of the string</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>strTrim is string -&#62; string</code></pre>
        <hr/>
        <h3><a name="field_strUncapitalize">strUncapitalize</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>strUncapitalize is string -&#62; string</code></pre>
        <hr/>
        <h3><a name="field_strUpper">strUpper</a></h3>
        <pre class="doc">String to upper case</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>strUpper is string -&#62; string</code></pre>
        <hr/>
        <h3><a name="field_string">string</a></h3>
        <pre class="doc">Convert any value into string representation</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>string is 'a -&#62; string</code></pre>
        <hr/>
        <h3><a name="field_substAll">substAll</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>substAll is string -&#62; string -&#62; string -&#62; string</code></pre>
        <hr/>
        <h3><a name="field_sum">sum</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>sum is list?&#60;number&#62; -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_swapAt">swapAt</a></h3>
        <pre class="doc">Swaps elements with keys i and j in mapping a</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>swapAt is map&#60;'a, 'b&#62; -&#62; 'a -&#62; 'a -&#62; ()</code></pre>
        <hr/>
        <h3><a name="field_synchronized">synchronized</a></h3>
        <pre class="doc">Acquires a mutual-exclusion lock on behalf of the executing thread,
 applies block to (), then releases the lock.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>synchronized is 'a -&#62; (() -&#62; 'b) -&#62; 'b</code></pre>
        <hr/>
        <h3><a name="field_tail">tail</a></h3>
        <pre class="doc">Rest of the list or array.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>tail is list?&#60;'a&#62; -&#62; list&#60;'a&#62;</code></pre>
        <hr/>
        <h3><a name="field_take">take</a></h3>
        <pre class="doc">Take first n elements from list l</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>take is number -&#62; list?&#60;'a&#62; -&#62; list&#60;'a&#62;</code></pre>
        <hr/>
        <h3><a name="field_takeWhile">takeWhile</a></h3>
        <pre class="doc">Take elements from the start of list l while predicate pred
 is true on the element.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>takeWhile is ('a -&#62; boolean) -&#62; list&#60;'a&#62; -&#62; list&#60;'a&#62;</code></pre>
        <hr/>
        <h3><a name="field_tan">tan</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>tan is number -&#62; number</code></pre>
        <hr/>
        <h3><a name="field_threadLocal">threadLocal</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>threadLocal is 'a -&#62; {var value is 'a}</code></pre>
        <hr/>
        <h3><a name="field_withExit">withExit</a></h3>
        <pre class="doc">Provide return function for block.
 Be careful with lazy lists, for example
 withExit do e: 1 :. \(e []) done
 fails with exit out scope error..</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>withExit is (('a -&#62; 'b) -&#62; 'a) -&#62; 'a</code></pre>
        <hr/>
        <h3><a name="field_wrapArray">wrapArray</a></h3>
        <pre class="doc">Wraps Java array object into Yeti array type.</pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>wrapArray is (array&#60;'a&#62; is 'b) -&#62; 'b</code></pre>
        <hr/>
        <h3><a name="field_xor">xor</a></h3>
        <pre class="doc"></pre>
        <!--<div class="codeheader">field-type:</div>-->
        <pre class="type"><code>xor is number -&#62; number -&#62; number</code></pre>
        <hr/>

        <h2><a name="source">Source</a></h2>
        <pre class="type"><code>/// Yeti standard library

/*
 * Copyright (c) 2008,2009 Madis Janson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR &#34;AS IS&#34; AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
module yeti.lang.std;

import java.lang.IllegalArgumentException;
import java.util.regex.Pattern;
import java.util.Map;

class FailureException(String what)
    extends RuntimeException(what)
end;

/// struct inner bindings are non-polymorphic
array l is list?&#60;'a&#62; -&#62; array&#60;'a&#62; =
    new MList(l) unsafely_as array&#60;'a&#62;;

fold f is ('a -&#62; 'b -&#62; 'a) -&#62; 'a -&#62; list?&#60;'b&#62; -&#62; 'a =
   (f2 v l is 'a -&#62; list?&#60;'b&#62; -&#62; 'a = // hack to get good code for gc
        if nullptr? l then
            v
        else
            (l unsafely_as ~AList)#fold(f, v) unsafely_as 'a
        fi;
    f2);

find f l is ('a -&#62; boolean) -&#62; list?&#60;'a&#62; -&#62; list&#60;'a&#62; =
    if nullptr? l then
        []
    else
        (l unsafely_as ~AList)#find(f) unsafely_as list&#60;'a&#62;
    fi;

index v l is 'a -&#62; list?&#60;'a&#62; -&#62; number =
    if nullptr? l then
        -1
    else
        res = (l unsafely_as ~AList)#index(v);
        if nullptr? res then -1 else res fi
    fi;

keys h is hash&#60;'a, 'b&#62; -&#62; list&#60;'a&#62; =
    if empty? h then
        []
    else
        new MList((h unsafely_as ~Map)#keySet()#toArray())
            unsafely_as list&#60;'a&#62;
    fi;

hash l is list?&#60;'a&#62; -&#62; hash&#60;'a, ()&#62; =
   (h = [:];
    for l (_ i = h.[i] := ());
    h);

/// Returns [f(a), f(b), ...] for list l [a, b, ...]
/// This map function returns lazy list when used on normal lists.
/// Arrays and lists backed by arrays are mapped strictly.
map f l is ('a -&#62; 'b) -&#62; list?&#60;'a&#62; -&#62; list&#60;'b&#62; =
    if empty? l then
        []
    else
        (l unsafely_as ~AList)#map(f) unsafely_as list&#60;'b&#62;
    fi;

/// Strict mapping of list. map' is usually faster than map on lists,
/// unless huge streams are processed or most of the resulting list is
/// not used. They work identically on arrays.
map' f l is ('a -&#62; 'b) -&#62; list?&#60;'a&#62; -&#62; list&#60;'b&#62; =
    if empty? l then
        []
    else
        (l unsafely_as ~AList)#smap(f) unsafely_as list&#60;'b&#62;
    fi;

peekObject object =
   (o = object unsafely_as ~Object;
    if nullptr? o then
        List []
    elif o instanceof String then
        String (o unsafely_as string)
    elif o instanceof Num then
        Number (o unsafely_as number)
    elif o instanceof Boolean then
        Boolean (o unsafely_as boolean)
    elif o instanceof AList then
        List (map peekObject (o unsafely_as list&#60;'a&#62;))
    elif o instanceof ByKey then
        result = [:];
        i = (o unsafely_as ~Map)#entrySet()#iterator();
        i#hasNext() loop
           (e = i#next() unsafely_as ~java.util.Map$Entry;
            result.[peekObject (e#getKey() unsafely_as 'a)] :=
                peekObject (e#getValue() unsafely_as 'a));
        Hash result
    elif o instanceof Struct then
        st = o unsafely_as ~Struct;
        fields = map' (_ n = st#name(n)) [0 .. st#count() - 1];
        Struct {
            fields,
            value name =
                i = (fields unsafely_as ~AList)#index(name);
                if nullptr? i then
                    throw new NoSuchKeyException(&#34;No such field (\(name))&#34;)
                fi;
                peekObject (st#get(i) unsafely_as 'a)
        }
    elif o instanceof Tag then
        t = o unsafely_as ~Tag;
        Variant {tag = t#name, value = peekObject (t#value unsafely_as 'a)}
    else
        Object o
    fi);

plus a b = a + b;

{
    none = None (),

    /// identity function (I combinator)
    id x = x,

    /// constant function (K combinator)
    const x _ = x,

    apply arg f = f arg,
    at h k = h.[k],

    /// f g x y = f (g x) (g y)
    /// for example sort (on (&#60;) (.name)) list
    on f g is ('a -&#62; 'a -&#62; 'b) -&#62; ('c -&#62; 'a) -&#62; 'c -&#62; 'c -&#62; 'b =
        new On(f, g) unsafely_as 'a, 

    /// functions for standard operators

    /// boolean logic
    norec (not) v = not v,
    norec (and) a b = a and b,
    norec (or) a b = a or b,

    /// element a in hash b
    norec (in) a b = a in b,

    /// comparision operators
    norec (==) a b = a == b,
    norec (!=) a b = a != b,
    norec (&#60;)  a b = a &#60;  b,
    norec (&#60;=) a b = a &#60;= b,
    norec (&#62;)  a b = a &#62;  b,
    norec (&#62;=) a b = a &#62;= b,

    /// arithmetic operators
    norec (+)      = plus,
    norec (-)  a b = a - b,
    norec (*)  a b = a * b,
    norec (/)  a b = a / b,
    norec (%)  a b = a % b,

    /// function composition - (f . g) x is same as f (g x)
    norec (.)  a b = a . b,

    /// list constructor a :: [b, c] is same as [a, b, c]
    norec (::) v l = v :: l,

    /// lazy list constructor a :. \[b] is same as [a, b], but the second
    /// lambda is invoked only when the tail is accessed for the first time.
    norec (:.) v l = v :. l,

    /// regex match, like s =~ '\d' to check whether string s contains number
    norec (=~) s p = s =~ p,

    /// negated regex match: s !~ p is same as not (s =~ p)
    norec (!~) s p = s !~ p,

    /// integer operations (when arguments are rational or floating numbers,
    /// then only the integer part of argument is used))
    norec (div) a b = a div b,
    norec (shl) a b = a shl b,
    norec (shr) a b = a shr b,
    norec (xor) a b = a xor b,
    norec (b_or) a b = a b_or b,
    norec (b_and) a b = a b_and b,

    /// negate a = -a
    norec negate a = negate a,

    /// Low-level nullpointer check.
    /// Use defined? instead, as nullptr? may behive unexpectedly together
    /// with some conversions done by yeti.
    norec nullptr? a = nullptr? a,

    /// checks whether value is defined
    norec defined? a = defined? a,

    /// Check whether a collection is empty one.
    norec empty? a = empty? a,

    /// First element of list or array.
    norec head a = head a,

    /// Rest of the list or array.
    norec tail a = tail a,

    /// Identity check - whether a and b are reference to same object.
    norec same? a b = same? a b,

    /// For every element of l call f with given element as argument.
    norec for l f = for l f,

    /// Acquires a mutual-exclusion lock on behalf of the executing thread,
    /// applies block to (), then releases the lock.
    norec synchronized monitor block = synchronized monitor block,

    /// String concatenation
    (^) a b = &#34;\(a)\(b)&#34;,

    /// List/array concatenation
    (++) a b is list?&#60;'a&#62; -&#62; list?&#60;'a&#62; -&#62; list&#60;'a&#62; =
        if empty? a then
            b unsafely_as ~Object unsafely_as 'a
        elif empty? b then
            a unsafely_as ~Object unsafely_as 'a
        else
            new ConcatList(a, b) unsafely_as list&#60;'a&#62;
        fi,

    /// damn struct polymorphism restriction. is it really needed?
    array, fold, find, index, keys, hash, map, map', peekObject,

    /// Wraps Java array object into Yeti array type.
    wrapArray a is 'a[] -&#62; array&#60;'a&#62; = a,

    /// Gives values from collection a as a list.
    list a is map&#60;'k, 'a&#62; -&#62; list&#60;'a&#62; =
        if empty? a then
            []
        else
            (a unsafely_as ~Coll)#asList() unsafely_as list&#60;'a&#62;
        fi,

    /// Swaps elements with keys i and j in mapping a
    swapAt a i j =
        x = a.[i];
        a.[i] := a.[j];
        a.[j] := x,

    /// Applies function to two arguments in reversed order.
    /// Useful for swapping binary functions arguments.
    flip f x y =
        f y x,

    /// Make function f to be memoizing.
    lazy f is (() -&#62; 'a) -&#62; (() -&#62; 'a) =
        new Lazy(f) unsafely_as (() -&#62; 'a),

    /// Construct a pair structure.
    pair fst snd =
        {fst, snd},

    /// Convert any value into string representation
    string x =
        &#34;\(x)&#34;,

    /// Convert string into number
    number x =
        Core#parseNum(x is string unsafely_as ~String),

    /// Numeric functions
    min a b =
        if a &#60; b then a else b fi,
    max a b =
        if a &#62; b then a else b fi,
    abs a =
        if a &#60; 0 then -a else a fi,
    sum l =
        fold plus 0 l,

    /// Flatten a list of lists.
    concat l is list?&#60;list?&#60;'a&#62;&#62; -&#62; list&#60;'a&#62; =
        if empty? l then
            []
        else
            ConcatLists#concat(l) unsafely_as list&#60;'a&#62;
        fi,

    /// Basically concat . map, but more effective.
    concatMap f l is ('a -&#62; list?&#60;'b&#62;) -&#62; list?&#60;'a&#62; -&#62; list&#60;'b&#62; =
        if empty? l then
            []
        else
            concat ((l unsafely_as ~AList)#map(f) unsafely_as list&#60;'a&#62;)
        fi,

    /// Is predicate f true for any element of list l?
    any f l =
        not nullptr? (find f l),

    /// Is predicate f true for all elements of list l?
    all f l =
        nullptr? (find (_ x = not f x) l),

    /// Returns first element of l for which predicate f is false
    /// or last element, when f returns false for all elements of l.
    avoid f l is ('a -&#62; boolean) -&#62; list?&#60;'a&#62; -&#62; 'a =
        if empty? l then
            throw new IllegalArgumentException(&#34;prefer: empty list&#34;)
        fi;
        var i = l unsafely_as ~AIter;
        var value = () as ~Object;
        (value := i#first();
         i := i#next();
         not nullptr? i and f (value unsafely_as 'a)) loop;
        value unsafely_as 'a,

    /// Whether l contains element equal (as defined by (==)) to v
    contains v l is 'a -&#62; list?&#60;'a&#62; -&#62; boolean =
        not (nullptr? l or nullptr? (l unsafely_as ~AList)#index(v)),

    /// Returns default when opt == None () and f x when opt == Some x
    maybe default f opt =
        case opt of
        Some v: f v;
        None _: default;
        esac,

    /// Splits given list into two parts, putting elements from the start of the
    /// list into fst as long as predicate function pred is false for the given
    /// element. The rest of the list is returned as snd.
    splitBy pred list is ('a -&#62; boolean) -&#62; list&#60;'a&#62;
                          -&#62; { fst is list&#60;'a&#62;, snd is list&#60;'a&#62; } = 
        a = new MList();
        var l = list; // over-optimized loop from hell. don't code like that.
        not empty? l and (h = head l; not pred h and (a#add(h); true)) loop
            l := tail l;
        { fst = if a#isEmpty() then [] else a unsafely_as list&#60;'a&#62; fi,
          snd = l },

    /// Splits given list into two parts, returning first n elements as fst
    /// and the rest as snd.
    splitAt n list is number -&#62; list&#60;'a&#62;
                      -&#62; { fst is list&#60;'a&#62;, snd is list&#60;'a&#62; } =
        a = new MList();
        var l = list;
        var n = n;
        if n &#60; 256 then
            a#reserve(n)
        fi;
        n &#62; 0 and not empty? l loop
           (a#add(head l);
            l := tail l;
            n := n - 1);
        { fst = if a#isEmpty() then [] else a unsafely_as list&#60;'a&#62; fi,
          snd = l },

    /// Take first n elements from list l
    take n l is number -&#62; list?&#60;'a&#62; -&#62; list&#60;'a&#62; =
        if nullptr? l then
            []
        else
            TakeList#take(l, n) unsafely_as list&#60;'a&#62;
        fi,

    /// Drop first n elements from list l. Won't copy the returned tail.
    drop n l =
        if n &#60;= 0 then
            l
        elif empty? l then
            []
        else
            drop (n - 1) (tail l)
        fi,

    /// Take elements from the start of list l while predicate pred
    /// is true on the element.
    takeWhile pred l is ('a -&#62; boolean) -&#62; list&#60;'a&#62; -&#62; list&#60;'a&#62; =
        if empty? l then
            []
        else
            TakeWhile#take(l, pred) unsafely_as list&#60;'a&#62;
        fi,

    /// Returns infinite list [x, f(x), f(f(x)), f(f(f(x))), ...]
    iterate f x is ('a -&#62; 'a) -&#62; 'a -&#62; list&#60;'a&#62; =
        new Iterate(x, f) unsafely_as list&#60;'a&#62;,

    /// Removes duplicate elements from the list.
    /// The ordering of list is not preserved.
    nub is list?&#60;'a&#62; -&#62; list&#60;'a&#62; =
        keys . hash,
    
    /// Returns a list of lists, where each sublist contains only equal elements
    /// and the concatenation of the result is equal to the original list l.
    /// Elements are considered equal when the given predicate function
    /// eq is true for them.
    groupBy eq l is ('a -&#62; 'a -&#62; boolean) -&#62; list?&#60;'a&#62; -&#62; list&#60;list&#60;'a&#62;&#62; =
        if empty? l then
            []
        else // this is an example of over-optimisation ;)
            var result = new MList();
            var collector = new MList();
            var i = l unsafely_as ~AIter;
            var prev = i#first();
            collector#add(prev);
            (i := i#next(); not nullptr? i) loop
               (val = i#first();
                if not ((val unsafely_as 'a) `eq` (prev unsafely_as 'a)) then
                    result#add(collector);
                    collector := new MList()
                fi;
                prev := val;
                collector#add(val));
            result#add(collector);
            result unsafely_as 'l
        fi,

    /// Sorts list. Same as sortBy (&#60;) l
    sort l is list?&#60;^a&#62; -&#62; list&#60;^a&#62; =
        if empty? l then
            []
        else
            (l unsafely_as ~AList)#sort() unsafely_as list&#60;^a&#62;
        fi,

    /// Sorts list using given less? predicate function to determine the order.
    /// Merge sort algorithm is used.
    sortBy less? l is ('a -&#62; 'a -&#62; boolean) -&#62; list?&#60;'a&#62; -&#62; list&#60;'a&#62; =
        if empty? l then
            []
        else
            (l unsafely_as ~AList)#sort(less?) unsafely_as list&#60;'a&#62;
        fi,

    // few math functions
    pi = Math#PI,
    ln a = Math#log(a),
    exp a = Math#exp(a),
    cos a = Math#cos(a),
    sin a = Math#sin(a),
    tan a = Math#tan(a),
    acos a = Math#acos(a),
    asin a = Math#asin(a),
    atan a = Math#atan(a),
    sqrt a = Math#sqrt(a),
    int a is number -&#62; number = (a as ~java.lang.Number)#longValue(),

    /// Replaces occurences of needle in the haystack with replacement
    strReplace needle replacement haystack =
        Core#replace(needle, replacement, haystack),

    /// String length
    norec strLength s = strLength s,

    /// String to upper case
    norec strUpper s = strUpper s,

    /// String to lower case
    norec strLower s = strLower s,

    /// Remove whitespace from start and end of the string
    norec strTrim s = strTrim s,

    /// Slice of the string
    norec strSlice s start end = strSlice s start end,

    /// Same as strSlice s pos (strLength s)
    norec strRight s pos = strRight s pos,

    /// Does the string s starts with string start?
    norec strStarts? s start = strStarts? s start,

    /// Does the string s ends with string end?
    norec strEnds? s end = strEnds? s end,

    /// Get an index of the needle substring in the haystack.
    /// Starts searching from index from
    norec strIndexOf haystack needle from = strIndexOf haystack needle from,

    /// Get an index of the needle substring in the haystack.
    /// Starts searching backwards from index from
    norec strLastIndexOf haystack needle from =
            strLastIndexOf haystack needle from,

    /// Same as strLastIndexOf haystack needle (strLength haystack)
    norec strLastIndexOf' haystack needle = strLastIndexOf haystack needle,

    norec strSplit re = strSplit re,
    norec substAll re = substAll re,
    norec matchAll re = matchAll re,
    norec like re = like re,
    norec strChar s pos = strChar s pos,

    strLeft s end = strSlice s 0 end,

    strLeftOf subString s is string -&#62; string -&#62; string =
        i = strIndexOf s subString 0;
        if i &#60; 0 then '' else strSlice s 0 i fi,

    strRightOf subString s is string -&#62; string -&#62; string =
        i = strLastIndexOf s subString 0;
        if i &#60; 0 then '' else strRight s (i + strLength subString) fi,

    strJoin sep list is string -&#62; list?&#60;'a&#62; -&#62; string =
        if empty? list then
            &#34;&#34;
        else
            buf = new java.lang.StringBuffer(&#34;\(head list)&#34;);
            var l = tail list;
            if strLength sep == 0 then
                not nullptr? l loop
                   (buf#append(&#34;\(head l)&#34;);
                    l := tail l)
            else
                not nullptr? l loop
                   (buf#append(sep);
                    buf#append(&#34;\(head l)&#34;);
                    l := tail l)
            fi;
            buf#toString()
        fi,

    strPad pad n str is string -&#62; number -&#62; string -&#62; string =
        if strLength str &#62;= n then
            str
        else
            buf = new java.lang.StringBuffer(str);
            buf#length() &#60; n loop buf#append(pad);
            buf#toString()
        fi,

    strCapitalize str is string -&#62; string =
        Core#capitalize(str unsafely_as ~String),

    strUncapitalize str is string -&#62; string =
        Core#uncapitalize(str unsafely_as ~String),

    forHash h f is hash&#60;'a, 'b&#62; -&#62; ('a -&#62; 'b -&#62; ()) -&#62; () =
        i = (h unsafely_as ~Map)#entrySet()#iterator();
        i#hasNext() loop
           (e = i#next() unsafely_as ~java.util.Map$Entry;
            f (e#getKey() unsafely_as 'a) (e#getValue() unsafely_as 'b)),

    mapHash f h is ('a -&#62; 'b -&#62; 'c) -&#62; hash&#60;'a, 'b&#62; -&#62; list?&#60;'c&#62; =
        a = new MList();
        a#reserve((h unsafely_as ~Map)#size());
        i = (h unsafely_as ~Map)#entrySet()#iterator();
        i#hasNext() loop
           (e = i#next() unsafely_as ~java.util.Map$Entry;
            a#add(f (e#getKey() unsafely_as 'a)
                    (e#getValue() unsafely_as 'b)));
        a unsafely_as list?&#60;'c&#62;,

    identityHash () is () -&#62; hash&#60;'a, 'b&#62; =
        new IdentityHash() unsafely_as hash&#60;'a, 'b&#62;,

    copy h is 'a -&#62; 'a =
        if nullptr? h then
            () as ~Object unsafely_as 'a
        else
            (h is map&#60;'a, 'b&#62; unsafely_as ~Coll)#copy() unsafely_as map&#60;'a, 'b&#62;
        fi,

    failWith message =
        throw new FailureException(message),

    delete h k is map&#60;'a, 'b&#62; -&#62; 'a -&#62; () =
        _ = (h unsafely_as ~ByKey)#remove(k),

    deleteAll h ks is map&#60;'a, 'b&#62; -&#62; list?&#60;'a&#62; -&#62; () =
        _ = (h unsafely_as ~ByKey)#removeAll(ks),

    setHashDefault h f is hash&#60;'a, 'b&#62; -&#62; ('a -&#62; 'b) -&#62; () =
        (h unsafely_as ~ByKey)#setDefault(f),

    clearHash h is hash&#60;'a, 'b&#62; -&#62; () =
        (h unsafely_as ~Map)#clear(),

    insertHash h h' is hash&#60;'a, 'b&#62; -&#62; hash&#60;'a, 'b&#62; -&#62; () =
        _ = (h unsafely_as ~Map)#putAll(h' unsafely_as ~Map),

    length l is map&#60;'a, 'b&#62; -&#62; number =
        if nullptr? l then
            0
        else
            (l unsafely_as ~Coll)#length()
        fi,

    setArrayCapacity a n is array&#60;'a&#62; -&#62; number -&#62; () =
        (a unsafely_as ~MList)#reserve(n),

    shift a is array&#60;'a&#62; -&#62; 'a =
        (a unsafely_as ~MList)#shift() unsafely_as 'a,

    pop a is array&#60;'a&#62; -&#62; 'a =
        (a unsafely_as ~MList)#pop() unsafely_as 'a,

    push a v is array&#60;'a&#62; -&#62; 'a -&#62; () =
        (a unsafely_as ~MList)#add(v),

    slice a start end is array&#60;'a&#62; -&#62; number -&#62; number -&#62; array&#60;'a&#62; =
        (a unsafely_as ~MList)#copy(start, end) unsafely_as array&#60;'a&#62;,

    collect f a endPred is ('a -&#62; 'b) -&#62; 'a -&#62; ('b -&#62; boolean) -&#62; list&#60;'b&#62; =
       (l = new MList();
        (v = f a; not endPred v and (l#add(v); true)) loop;
        if l#isEmpty() then
            []
        else
            l unsafely_as list&#60;'a&#62;
        fi),

    filter f l is ('a -&#62; boolean) -&#62; list?&#60;'a&#62; -&#62; list&#60;'a&#62; =
        if empty? l then
            []
        else
            FilterList#filter(l, f) unsafely_as list&#60;'a&#62;
        fi,

    catSome l is list?&#60;Some 'a | None 'b&#62; -&#62; list&#60;'a&#62; =
        if empty? l then
            []
        else
            CatSomes#filter(l) unsafely_as list&#60;'a&#62;
        fi,

    map2 f a b is ('a -&#62; 'b -&#62; 'c) -&#62; list?&#60;'a&#62; -&#62; list?&#60;'b&#62; -&#62; list&#60;'c&#62; =
        if empty? a or empty? b then
            []
        else
            new Map2List(f, a, b) unsafely_as list&#60;'c&#62;
        fi,

    revAppend a b is list?&#60;'a&#62; -&#62; list&#60;'a&#62; -&#62; list&#60;'a&#62; =
        if empty? a then
            b
        else
            var a = a unsafely_as ~AIter;
            var res = b;
            not nullptr? a loop
               (res := (a#first() unsafely_as 'a) :: res;
                a := a#next());
            res
        fi,

    reverse l is list?&#60;'a&#62; -&#62; list&#60;'a&#62; =
        if nullptr? l then
            []
        else
            (l unsafely_as ~AList)#reverse() unsafely_as list&#60;'a&#62;
        fi,

    /// Provide return function for block.
    /// Be careful with lazy lists, for example
    /// withExit do e: 1 :. \(e []) done
    /// fails with exit out scope error..
    withExit f is (('a -&#62; 'b) -&#62; 'a) -&#62; 'a =
        EscapeFun#with(f) unsafely_as 'a,

    threadLocal initialValue is 'a -&#62; {var value is 'a} =
        class Local extends java.lang.ThreadLocal
            Object initialValue() initialValue
        end;
        tl = new Local();
        {
            get value () = tl#get() unsafely_as 'a,
            set value v  = tl#set(v)
        }
}
</code></pre>

    </div></div></div>

    <div id="leftcolumn"><div class="innertube">
        <!--<b>Left Column: <em>200px</em></b> <script type="text/javascript">filltext(15)</script> -->
               <h4>modules</h4>
        <ul><li><a href="yeti$lang$std.html">yeti.lang.std</a></li>
             <li><a href="yeti$lang$compiler$repl.html">yeti.lang.compiler.repl</a></li>
             <li><a href="yeti$http.html">yeti.http</a></li>
             <li><a href="std.html">std</a></li>
             <li><a href="some1.html">some1</a></li>
             <li><a href="some.html">some</a></li></ul>

    </div></div>

    <div id="footer">
        <a href="http://mth.github.com/yeti/">Yeti - home</a>
    </div>
</div>
</body>
</html>
